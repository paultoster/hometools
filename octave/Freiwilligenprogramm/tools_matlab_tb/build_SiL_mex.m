function okay = build_SiL_mex(root_dir)
%
%  okay = build_SiL_mex(root_dir)
%
%  Erstellt ein mex-Verzeichnis mit allen notwendigen Dateien um 
%  das rtas für mex-Files zu benutzen. Dazu muß eine rtas-simulink-Version
%  erstellt werden, die dann als Vorlage dient
%
%  root_dir         Das root-Verzeichnis um das rtas-Projekt auszuwählen,
%                   wenn nicht vorhanden, wird D\: verwendet
%
% VCLIB_NAME = 'vc9lib';  müssen unterumständen angepasst werden
% VC_EXT     = 'vcproj';

  r.VCLIB_NAME = 'vc9lib';
  r.VC_EXT     = 'vcproj';
  r.DLLEXT     = '.mexw32';

  % check root dir
  if( ~exist('root_dir','var') )
    root_dir = 'd:\';
    if( ~exist(root_dir,'dir') )
      [c_names,icount] = str_split(pwd,':');
      root_dir = [c_names{1},':\'];
    end
  end


  % Projekt auswählen:
  %-------------------
  s_frage.comment   = 'SiL-Verzeichnis mit dem Modul auswählen';
  s_frage.start_dir = root_dir;
  [okay,c_dirname]  = o_abfragen_dir_f(s_frage);

  if( ~okay )
    error('Abruch in o_abfragen_dir()');
  end
  [c_names,n]  = str_split(c_dirname{1},'\');
  
  r.modul_dir  = c_dirname{1};
  r.modul_name = c_names{n};
  
  
  % mex-Path erstellen
  %====================
  r.mex_lib_dir = fullfile(r.modul_dir,'_mexlib');
  if( ~exist(r.mex_lib_dir,'dir') )
    [s, mess, messid] = mkdir(r.mex_lib_dir);
    if( s == 0 )
      error(mess);
    end
  end
  
  r.mex_work_debug_dir = fullfile(r.modul_dir,'work\mex\debug');
  if( ~exist(r.mex_work_debug_dir,'dir') )
    [s, mess, messid] = mkdir(r.mex_work_debug_dir);
    if( s == 0 )
      error(mess);
    end
  end
  
  r.mex_work_release_dir = fullfile(r.modul_dir,'work\mex\release');
  if( ~exist(r.mex_work_release_dir,'dir') )
    [s, mess, messid] = mkdir(r.mex_work_release_dir);
    if( s == 0 )
      error(mess);
    end
  end
  

  % vcproj für mex kopieren und namen ersetzen
  %-------------------------------------------
  r.simulink_vcproj_file = fullfile(r.modul_dir,[r.modul_name,'_simulink.vcproj']);
  r.mex_vcproj_file      = fullfile(r.modul_dir,[r.modul_name,'_mex.vcproj']);

  if( ~exist(r.simulink_vcproj_file,'file') )
    error('Fehler Datei <%s> konnte nich gefunden werden',r.simulink_vcproj_file)
  end

  liste_such   = {'simulink', 'sfunc_'};
  liste_ersetz = {'mex'     , 'mex_'  };

  [okay,mess] = change_text_in_new_file(r.simulink_vcproj_file, r.mex_vcproj_file,liste_such,liste_ersetz);
  if( ~okay )
    error(mess);
  end
  fprintf('mex-vcproj-File:       %s erstellt\n',r.mex_vcproj_file);

  


  % mex_fr.cpp erstellen
  %---------------------
  c1 = build_rtas_mex_c_file_text;
  c1 = cell_change(c1,'$$MOD_NAME$$',r.modul_name);
  
  r.mex_fr_cpp_file = fullfile(r.mex_lib_dir,'mex_fr.cpp');
  okay = write_ascii_file(r.mex_fr_cpp_file,c1);
  if( ~okay )
    error('Fehler bei Schreiben von mex_fr-File in: <%s>',r.mex_fr_cpp_file);
  end

  % _createXXX.py erstellen
  %------------------------
  c1 = get_mex_py_file;
  c1 = cell_change(c1,'$$MOD_NAME$$',r.modul_name);
  c1 = cell_change(c1,'$$ABOSTR$$','"""');

  r.create_py_file = fullfile(r.mex_work_debug_dir,['_create_',r.modul_name,'.py']);
  okay = write_ascii_file(r.create_py_file,c1);
  if( ~okay )
    error('Fehler bei Schreiben von create-py-File in: <%s>',r.create_py_file);
  end
end

function c = build_rtas_mex_c_file_text

  c = ...
  {'////////////////////////////////////////////////////////////////////////////////////////////////' ...
  ,'//                                                                                            //' ...
  ,'//                                mex_fr.cpp                                                  //' ...
  ,'//                                                                                            //' ...
  ,'////////////////////////////////////////////////////////////////////////////////////////////////' ...
  ,'//                                                                                            //' ...
  ,'//                     mex wrapper for wave task module                                       //' ...
  ,'//                                                                                            //' ...
  ,'////////////////////////////////////////////////////////////////////////////////////////////////' ...
  ,'' ...
  ,'#define MEX_FUNCTION_NAME       "mex_$$MOD_NAME$$"' ...
  ,'' ...
  ,'/*' ...
  ,'* Need to include simstruc.h for the definition of the SimStruct and' ...
  ,'* its associated macro definitions.' ...
  ,'*/' ...
  ,'#include "mex.h"' ...
  ,'#include "matrix.h"' ...
  ,'#include "wave_fun.h"' ...
  ,'#include <math.h>' ...
  ,'' ...
  ,'/*****************************************/' ...
  ,'/*          locals                       */' ...
  ,'/*****************************************/' ...
  ,'static StrListT WaveInpNames;' ...
  ,'static StrListT WaveOutNames;' ...
  ,'' ...
  ,'/*****************************************/' ...
  ,'/*          wave function interface      */' ...
  ,'/*****************************************/' ...
  ,'extern int  WavE_Init();' ...
  ,'extern int  WavE_Loop();' ...
  ,'extern int  WavE_Done();' ...
  ,'' ...
  ,'/*****************************************/' ...
  ,'/*          wave variable interface      */' ...
  ,'/*****************************************/' ...
  ,'#include "variables.cpp"' ...
  ,'' ...
  ,'void mexFunctionRead_Init(const mxArray *pinfo,const mxArray *pinput);' ...
  ,'void mexFunctionSet_Output(mxArray **ppoutput);' ...
  ,'void mexFunctionRead_Loop(const mxArray *pinput);' ...
  ,'void mexFunctionWrite_Loop(mxArray **ppoutput);' ...
  ,'void mexFunction_Done(void);' ...
  ,'' ...
  ,'struct SInfo {' ...
  ,'' ...
  ,'    unsigned char        init_done;' ...
  ,'    int                  number_of_inputs;' ...
  ,'    int                 *pinput_index;' ...
  ,'    int                  number_of_outputs;' ...
  ,'    char               **pp_output_name_list;' ...
  ,'    double               delta_t;' ...
  ,'    double               time;' ...
  ,'};' ...
  ,'SInfo Info = {0,0,0,0,0,0.0,0.0};' ...
  ,'' ...
  ,'/*=====================*' ...
  ,'* mex-function methods *' ...
  ,'*=====================*/' ...
  ,'// y = function(''i'',info,input);' ...
  ,'// y = function(''l'',info,input);' ...
  ,'// y = function(''d'');' ...
  ,'// -----------------' ...
  ,'// state   = ''i'';     % init' ...
  ,'//         = ''l'';     % loop' ...
  ,'//         = ''d'';     % done' ...
  ,'// info.delta_t = delta_t; % Zeitschrittgröße' ...
  ,'//' ...
  ,'// input-Struktur' ...
  ,'// ----------------' ...
  ,'// input.name   = input;   % Inputgrößen (Skalar)' ...
  ,'//' ...
  ,'// y: output-Struktur' ...
  ,'// ------------------' ...
  ,'// y.okay               % =1:Ist Okay/=2:Warnung/=1:Fehler' ...
  ,'// y.message            % Nachricht' ...
  ,'// y.output             % Outputgröße (Skalar)' ...
  ,'//--------------------------------------------------------------' ...
  ,'// function: mexFunction - Entry point from Matlab environment' ...
  ,'// INPUTS:' ...
  ,'//   nlhs - number of left hand side arguments (outputs)' ...
  ,'//   plhs[] - pointer to table where created matrix pointers are' ...
  ,'//            to be placed' ...
  ,'//   nrhs - number of right hand side arguments (inputs)' ...
  ,'//   prhs[] - pointer to table of input matrices' ...
  ,'//--------------------------------------------------------------' ...
  ,'void mexFunction( int nlhs, mxArray *plhs[], int nrhs, const mxArray  *prhs[] )' ...
  ,'{' ...
  ,'  unsigned char state;' ...
  ,'' ...
  ,'' ...
  ,'  // Prüfen, ob erster Parameter ein Wert ist' ...
  ,'  if( (nrhs < 1) || !mxIsChar(prhs[0]) ) {' ...
  ,'    mexErrMsgTxt(MEX_FUNCTION_NAME"_error: erster Parameter muß ein Wert sein (''i'': init,''l'': loop,''d'': done) ");' ...
  ,'  } else {' ...
  ,'    char *input_buf = mxArrayToString(prhs[0]);' ...
  ,'    state = input_buf[0];' ...
  ,'    if(  (state != ''i'') && (state != ''I'')' ...
  ,'      && (state != ''l'') && (state != ''L'')' ...
  ,'      && (state != ''d'') && (state != ''D'')' ...
  ,'      ) {' ...
  ,'      mexErrMsgTxt(MEX_FUNCTION_NAME"_error: erster Parameter muß einen entsprechenden Wert haben (''i'': init,''l'': loop,''d'': done) ");' ...
  ,'    }' ...
  ,'  }' ...
  ,'' ...
  ,'  // Steuerung mit state' ...
  ,'  switch(state)' ...
  ,'  {' ...
  ,'  // Initialisieren' ...
  ,'  //---------------' ...
  ,'  case ''i'':' ...
  ,'  case ''I'':' ...
  ,'' ...
  ,'    // Alles zurücksetzen' ...
  ,'    mexFunction_Done();' ...
  ,'' ...
  ,'    // Prüfen des zweiten Parameters info (struktur)' ...
  ,'    if( (nrhs < 2) || !mxIsStruct(prhs[1]) ) {' ...
  ,'      mexErrMsgTxt(MEX_FUNCTION_NAME"_error(init): zweiter Parameter muß eine Struktur sein (info)");' ...
  ,'    }' ...
  ,'    // Prüfen des dritten Parameters input (struktur)' ...
  ,'    if( (nrhs < 3) || !mxIsStruct(prhs[2]) ) {' ...
  ,'      mexErrMsgTxt(MEX_FUNCTION_NAME"_error(init): dritter Parameter muß eine Struktur sein (input)");' ...
  ,'    }' ...
  ,'' ...
  ,'    mexFunctionRead_Init(prhs[1],prhs[2]);' ...
  ,'' ...
  ,'    if( WavE_Init() ) {' ...
  ,'      mexFunction_Done();' ...
  ,'      mexErrMsgTxt(MEX_FUNCTION_NAME"_error(init): Initialisiereungsfehler");' ...
  ,'    }' ...
  ,'' ...
  ,'' ...
  ,'' ...
  ,'    // Ausgabe anlegen' ...
  ,'    if( nlhs > 0 )' ...
  ,'      mexFunctionSet_Output(&plhs[0]);' ...
  ,'' ...
  ,'' ...
  ,'    mexPrintf("mexFunction: <%s>\\n\\n",MEX_FUNCTION_NAME);' ...
  ,'' ...
  ,'    break;' ...
  ,'  // Loop-Berechnung' ...
  ,'  //----------------' ...
  ,'  case ''l'':' ...
  ,'  case ''L'':' ...
  ,'' ...
  ,'    // Prüfen des dritten Parameters input (struktur)' ...
  ,'    if( (nrhs < 2) || !mxIsStruct(prhs[1]) ) {' ...
  ,'      mexErrMsgTxt(MEX_FUNCTION_NAME"_error(loop): zweiter Parameter muß eine Struktur sein (input)");' ...
  ,'    }' ...
  ,'' ...
  ,'    mexFunctionRead_Loop(prhs[1]);' ...
  ,'' ...
  ,'    Info.time += Info.delta_t;' ...
  ,'' ...
  ,'    WavE_Loop();' ...
  ,'' ...
  ,'    if( nlhs > 0 )' ...
  ,'      mexFunctionWrite_Loop(&plhs[0]);' ...
  ,'' ...
  ,'    break;' ...
  ,'  case ''d'':' ...
  ,'  case ''D'':' ...
  ,'' ...
  ,'    WavE_Done();' ...
  ,'    mexFunction_Done();' ...
  ,'    break;' ...
  ,'  }' ...
  ,'' ...
  ,'' ...
  ,'}' ...
  ,'void mexFunctionRead_Init(const mxArray *pinfo,const mxArray *pinput)' ...
  ,'{' ...
  ,'  int           nfields;' ...
  ,'  int           ifield;' ...
  ,'  mxArray       *pvalue;' ...
  ,'  const char    *fieldname;' ...
  ,'  unsigned char flag = 0;' ...
  ,'  unsigned char flag_dt = 0;' ...
  ,'' ...
  ,'  // Schleife über alle info-Strukturelemente' ...
  ,'  //=========================================' ...
  ,'  nfields = mxGetNumberOfFields(pinfo);' ...
  ,'  for( ifield=0;ifield<nfields;ifield++) {' ...
  ,'' ...
  ,'    pvalue    = mxGetFieldByNumber(pinfo, 0, ifield);' ...
  ,'    fieldname = mxGetFieldNameByNumber(pinfo,ifield);' ...
  ,'' ...
  ,'' ...
  ,'    if( mxIsNumeric(pvalue) ) { // Prüfen, ob Wert' ...
  ,'' ...
  ,'      if( strcmp(fieldname,"delta_t") == 0 ) {' ...
  ,'' ...
  ,'        Info.delta_t = *mxGetPr(pvalue);' ...
  ,'        flag_dt       = 1;' ...
  ,'' ...
  ,'      }' ...
  ,'    }' ...
  ,'  }' ...
  ,'' ...
  ,'  // Zuordnung der Inputnamen bilden' ...
  ,'  //================================' ...
  ,'  nfields = mxGetNumberOfFields(pinput);' ...
  ,'' ...
  ,'  // generate wave-inputs' ...
  ,'  WaveInpNames.clear();' ...
  ,'  GetInpNames(WaveInpNames, VART_NUMBER);' ...
  ,'  Info.number_of_inputs = WaveInpNames.size();' ...
  ,'' ...
  ,'  if( Info.number_of_inputs > 0)' ...
  ,'  {' ...
  ,'    int inp_index = 0;' ...
  ,'    StrListT::iterator inp_iter = WaveInpNames.begin();' ...
  ,'' ...
  ,'' ...
  ,'    Info.pinput_index = new int[Info.number_of_inputs];' ...
  ,'    while(inp_iter != WaveInpNames.end())' ...
  ,'    {' ...
  ,'      std::string var_name = *inp_iter;' ...
  ,'      int var_length = GetVarLength(var_name);' ...
  ,'' ...
  ,'      // In matlab struktur suchen' ...
  ,'      flag = 0;' ...
  ,'      Info.pinput_index[inp_index] = 0;' ...
  ,'      for( ifield=0;ifield<nfields;ifield++) {' ...
  ,'' ...
  ,'        pvalue    = mxGetFieldByNumber(pinput, 0, ifield);' ...
  ,'        fieldname = mxGetFieldNameByNumber(pinput,ifield);' ...
  ,'' ...
  ,'        if( mxIsNumeric(pvalue) ) { // Prüfen, ob Wert' ...
  ,'' ...
  ,'          if( strcmp(fieldname,var_name.c_str()) == 0 ) {' ...
  ,'            Info.pinput_index[inp_index] = ifield;' ...
  ,'            flag                         = 1;' ...
  ,'          }' ...
  ,'        }' ...
  ,'        if( flag )' ...
  ,'          break;' ...
  ,'      }' ...
  ,'      inp_index++;' ...
  ,'      inp_iter++;' ...
  ,'    }' ...
  ,'  }' ...
  ,'' ...
  ,'' ...
  ,'  // Init Flag' ...
  ,'  if( !flag_dt )' ...
  ,'     mexErrMsgTxt(MEX_FUNCTION_NAME"_error: In zweiter Parameterstruktur info wurde delta_t nicht gelesen");' ...
  ,'' ...
  ,'  // delta_dt' ...
  ,'  Info.delta_t = fabs(Info.delta_t);' ...
  ,'  if( Info.delta_t < 1e-10 )' ...
  ,'     mexErrMsgTxt(MEX_FUNCTION_NAME"_error: In zweiter Parameterstruktur info ist delta_t zu klein");' ...
  ,'' ...
  ,'  Info.init_done = 1;' ...
  ,'  Info.time      = 0.0;' ...
  ,'}' ...
  ,'void mexFunctionSet_Output(mxArray **ppoutput)' ...
  ,'{' ...
  ,'  char *p_name;' ...
  ,'  int dims[2];' ...
  ,'  double *pvalue;' ...
  ,'' ...
  ,'  WaveOutNames.clear();' ...
  ,'  GetOutNames(WaveOutNames, VART_NUMBER);' ...
  ,'  if(WaveOutNames.size() > 0) {' ...
  ,'' ...
  ,'    // Die Outputnamen sammeln' ...
  ,'    Info.number_of_outputs = WaveOutNames.size();' ...
  ,'    Info.pp_output_name_list = new char *[Info.number_of_outputs];' ...
  ,'' ...
  ,'    int out_index = 0;' ...
  ,'    StrListT::iterator out_iter = WaveOutNames.begin();' ...
  ,'    while(out_iter != WaveOutNames.end())' ...
  ,'    {' ...
  ,'      std::string var_name = *out_iter;' ...
  ,'' ...
  ,'      p_name = new char[var_name.length()+1];' ...
  ,'      strcpy(p_name,var_name.c_str());' ...
  ,'      Info.pp_output_name_list[out_index] = p_name;' ...
  ,'' ...
  ,'      out_index++;' ...
  ,'      out_iter++;' ...
  ,'    }' ...
  ,'    // matlab-struktur anlegen' ...
  ,' 		dims[0] = 1;' ...
  ,'		dims[1] = 1;' ...
  ,'    *ppoutput = mxCreateStructArray(2,dims,Info.number_of_outputs,(const char **)Info.pp_output_name_list);' ...
  ,'' ...
  ,'' ...
  ,'    // Werte anlegen' ...
  ,'    WaveOutNames.clear();' ...
  ,'    GetOutNames(WaveOutNames, VART_NUMBER);' ...
  ,'    out_index = 0;' ...
  ,'    out_iter = WaveOutNames.begin();' ...
  ,' 		dims[0] = 1;' ...
  ,'		dims[1] = 1;' ...
  ,'    double value;' ...
  ,'    mxArray *parray;' ...
  ,'    while(out_iter != WaveOutNames.end())' ...
  ,'    {' ...
  ,'      parray = mxCreateNumericArray(2,dims,mxDOUBLE_CLASS,mxREAL);' ...
  ,'      pvalue = mxGetPr(parray);' ...
  ,'' ...
  ,'      if( GetOutValue(*out_iter, value, 0) ) {' ...
  ,'        // Werte Anlegen' ...
  ,'        *pvalue = value;' ...
  ,'      } else {' ...
  ,'        *pvalue = 0.0;' ...
  ,'      }' ...
  ,'      mxSetFieldByNumber(*ppoutput,0,out_index,parray);' ...
  ,'      out_index++;' ...
  ,'      out_iter++;' ...
  ,'    }' ...
  ,'' ...
  ,'' ...
  ,'' ...
  ,'  }' ...
  ,'' ...
  ,'}' ...
  ,'void mexFunctionRead_Loop(const mxArray *pinput)' ...
  ,'{' ...
  ,'  mxArray *parray;' ...
  ,'  double  value;' ...
  ,'  int ifield;' ...
  ,'  int nfields = mxGetNumberOfFields(pinput);' ...
  ,'  StrListT::iterator iter = WaveInpNames.begin();' ...
  ,'  for(int i = 0; i < Info.number_of_inputs; i++)' ...
  ,'  {' ...
  ,'    if(iter != WaveInpNames.end())' ...
  ,'    {' ...
  ,'      ifield = Info.pinput_index[i];' ...
  ,'      if( ifield >= nfields )' ...
  ,'        ifield = nfields-1;' ...
  ,'      parray    = mxGetFieldByNumber(pinput, 0, ifield );' ...
  ,'' ...
  ,'      if(parray)' ...
  ,'      {' ...
  ,'        value = *mxGetPr(parray);' ...
  ,'        SetInpValue(*iter, value, 0);' ...
  ,'      }' ...
  ,'      iter++;' ...
  ,'    }' ...
  ,'  }' ...
  ,'}' ...
  ,'void mexFunctionWrite_Loop(mxArray **ppoutput)' ...
  ,'{' ...
  ,'  int dims[2];' ...
  ,'  double *pvalue;' ...
  ,'' ...
  ,'  // matlab-struktur anlegen' ...
  ,'	dims[0] = 1;' ...
  ,'	dims[1] = 1;' ...
  ,'  *ppoutput = mxCreateStructArray(2,dims,Info.number_of_outputs,(const char **)Info.pp_output_name_list);' ...
  ,'' ...
  ,'' ...
  ,'  // Werte anlegen' ...
  ,'  WaveOutNames.clear();' ...
  ,'  GetOutNames(WaveOutNames, VART_NUMBER);' ...
  ,'  int out_index = 0;' ...
  ,'  StrListT::iterator out_iter = WaveOutNames.begin();' ...
  ,'	dims[0] = 1;' ...
  ,'	dims[1] = 1;' ...
  ,'  double value;' ...
  ,'  mxArray *parray;' ...
  ,'  while(out_iter != WaveOutNames.end())' ...
  ,'  {' ...
  ,'    parray = mxCreateNumericArray(2,dims,mxDOUBLE_CLASS,mxREAL);' ...
  ,'    pvalue = mxGetPr(parray);' ...
  ,'' ...
  ,'    if( GetOutValue(*out_iter, value, 0) ) {' ...
  ,'      // Werte Anlegen' ...
  ,'      *pvalue = value;' ...
  ,'    } else {' ...
  ,'      *pvalue = 0.0;' ...
  ,'    }' ...
  ,'    mxSetFieldByNumber(*ppoutput,0,out_index,parray);' ...
  ,'    out_index++;' ...
  ,'    out_iter++;' ...
  ,'  }' ...
  ,'' ...
  ,'}' ...
  ,'//void mexFunctionWrite_Loop(void)' ...
  ,'//{' ...
  ,'//  double value;' ...
  ,'//  double *pvalue;' ...
  ,'//  StrListT::iterator iter = WaveOutNames.begin();' ...
  ,'//  for(int i = 0; i < Info.number_of_outputs; i++)' ...
  ,'//  {' ...
  ,'//    if(iter != WaveOutNames.end())' ...
  ,'//    {' ...
  ,'//      if(Info.ppoutput[i])' ...
  ,'//      {' ...
  ,'//        pvalue = mxGetPr(Info.ppoutput[i]);' ...
  ,'//        if( GetOutValue(*iter, value, 0) ) {' ...
  ,'//          *pvalue = value;' ...
  ,'//        } else {' ...
  ,'//          *pvalue = 0.0;' ...
  ,'//        }' ...
  ,'//      }' ...
  ,'//      iter++;' ...
  ,'//    }' ...
  ,'//  }' ...
  ,'//}' ...
  ,'' ...
  ,'void mexFunction_Done(void)' ...
  ,'{' ...
  ,'  if( Info.pinput_index ) {' ...
  ,'    delete []Info.pinput_index;' ...
  ,'  }' ...
  ,'  if( Info.number_of_outputs > 0 ) {' ...
  ,'	  for(int i=0;i<Info.number_of_outputs;i++){' ...
  ,'      char *p_name = Info.pp_output_name_list[i];' ...
  ,'      delete p_name;' ...
  ,'    }' ...
  ,'    delete []Info.pp_output_name_list;' ...
  ,'  }' ...
  ,'  Info.delta_t          = 0.0;' ...
  ,'  Info.init_done        = 0;' ...
  ,'  Info.number_of_inputs = 0;' ...
  ,'  Info.pinput_index     = 0;' ...
  ,'  Info.number_of_outputs   = 0;' ...
  ,'  Info.pp_output_name_list = 0;' ...
  ,'}' ...
  ,'#if 0' ...
  ,'static void mdlInitializeSizes(SimStruct *S)' ...
  ,'{' ...
  ,'' ...
  ,'  /* See sfuntmpl_doc.c for more details on the macros below */' ...
  ,'  ssSetNumContStates(S, 0);' ...
  ,'  ssSetNumDiscStates(S, 0);' ...
  ,'' ...
  ,'  // generate inputs' ...
  ,'  WaveInpNames.clear();' ...
  ,'  GetInpNames(WaveInpNames, VART_NUMBER);' ...
  ,'  if(WaveInpNames.size() > 0)' ...
  ,'  {' ...
  ,'    if (!ssSetNumInputPorts(S, (int)WaveInpNames.size())) return;' ...
  ,'    int inp_index = 0;' ...
  ,'    StrListT::iterator inp_iter = WaveInpNames.begin();' ...
  ,'    while(inp_iter != WaveInpNames.end())' ...
  ,'    {' ...
  ,'      std::string var_name = *inp_iter;' ...
  ,'      int var_length = GetVarLength(var_name);' ...
  ,'      ssSetInputPortWidth(S, inp_index, var_length);' ...
  ,'      inp_index++;' ...
  ,'      inp_iter++;' ...
  ,'    }' ...
  ,'  }' ...
  ,'  else' ...
  ,'  {' ...
  ,'    if(!ssSetNumInputPorts(S, 0)) return;' ...
  ,'  }' ...
  ,'' ...
  ,'  // generate outputs' ...
  ,'  WaveOutNames.clear();' ...
  ,'  GetOutNames(WaveOutNames, VART_NUMBER);' ...
  ,'  if(WaveOutNames.size() > 0)' ...
  ,'  {' ...
  ,'    if (!ssSetNumOutputPorts(S, WaveOutNames.size())) return;' ...
  ,'    int out_index = 0;' ...
  ,'    StrListT::iterator out_iter = WaveOutNames.begin();' ...
  ,'    while(out_iter != WaveOutNames.end())' ...
  ,'    {' ...
  ,'      std::string var_name = *out_iter;' ...
  ,'      int var_length = GetVarLength(var_name);' ...
  ,'      ssSetOutputPortWidth(S, out_index, var_length);' ...
  ,'      out_index++;' ...
  ,'      out_iter++;' ...
  ,'    }' ...
  ,'  }' ...
  ,'  else' ...
  ,'  {' ...
  ,'    if(!ssSetNumOutputPorts(S, 0)) return;' ...
  ,'  }' ...
  ,'' ...
  ,'  ssSetNumSampleTimes(S, 1);' ...
  ,'' ...
  ,'  ssSetNumRWork(S, 0);' ...
  ,'  ssSetNumIWork(S, 0);' ...
  ,'  ssSetNumPWork(S, 0);' ...
  ,'  ssSetNumModes(S, 0);' ...
  ,'  ssSetNumNonsampledZCs(S, 0);' ...
  ,'' ...
  ,'  ssSetOptions(S, 0);' ...
  ,'}' ...
  ,'' ...
  ,'/* Function: mdlInitializeSampleTimes =========================================' ...
  ,'* Abstract:' ...
  ,'*    This function is used to specify the sample time(s) for your' ...
  ,'*    S-function. You must register the same number of sample times as' ...
  ,'*    specified in ssSetNumSampleTimes.' ...
  ,'*/' ...
  ,'static void mdlInitializeSampleTimes(SimStruct *S)' ...
  ,'{' ...
  ,'  ssSetSampleTime(S, 0, INHERITED_SAMPLE_TIME);' ...
  ,'  ssSetOffsetTime(S, 0, 0.0);' ...
  ,'}' ...
  ,'' ...
  ,'#define MDL_START  /* Change to #undef to remove function */' ...
  ,'#if defined(MDL_START)' ...
  ,'/* Function: mdlStart =======================================================' ...
  ,'* Abstract:' ...
  ,'*    This function is called once at start of model execution. If you' ...
  ,'*    have states that should be initialized once, this is the place' ...
  ,'*    to do it.' ...
  ,'*/' ...
  ,'static void mdlStart(SimStruct *S)' ...
  ,'{' ...
  ,'  WavE_Init();' ...
  ,'}' ...
  ,'#endif /*  MDL_START */' ...
  ,'' ...
  ,'/* Function: mdlOutputs =======================================================' ...
  ,'* Abstract:' ...
  ,'*    In this function, you compute the outputs of your S-function' ...
  ,'*    block. Generally outputs are placed in the output vector, ssGetY(S).' ...
  ,'*/' ...
  ,'static void mdlOutputs(SimStruct *S, int_T tid)' ...
  ,'{' ...
  ,'  // transfer values from module output to simulink' ...
  ,'  int nOutputPorts = ssGetNumOutputPorts(S);' ...
  ,'  StrListT::iterator iter = WaveOutNames.begin();' ...
  ,'  for(int i = 0; i < nOutputPorts; i++)' ...
  ,'  {' ...
  ,'    real_T *y = ssGetOutputPortRealSignal(S,i);' ...
  ,'    int_T outputs = ssGetOutputPortWidth(S,i);' ...
  ,'    if(iter != WaveOutNames.end())' ...
  ,'    {' ...
  ,'      for(int p = 0; p < outputs; p++)' ...
  ,'      {' ...
  ,'        double value = 0.0;' ...
  ,'        if(GetOutValue(*iter, value, p))' ...
  ,'        {' ...
  ,'          y[p] = value;' ...
  ,'        }' ...
  ,'      }' ...
  ,'      iter++;' ...
  ,'    }' ...
  ,'  }' ...
  ,'}' ...
  ,'' ...
  ,'#define MDL_UPDATE  /* Change to #undef to remove function */' ...
  ,'#if defined(MDL_UPDATE)' ...
  ,'/* Function: mdlUpdate ======================================================' ...
  ,'* Abstract:' ...
  ,'*    This function is called once for every major integration time step.' ...
  ,'*    Discrete states are typically updated here, but this function is useful' ...
  ,'*    for performing any tasks that should only take place once per' ...
  ,'*    integration step.' ...
  ,'*/' ...
  ,'static void mdlUpdate(SimStruct *S, int_T tid)' ...
  ,'{' ...
  ,'  // transfer values from simlink to module input variables' ...
  ,'  int nInputPorts = ssGetNumInputPorts(S);' ...
  ,'  StrListT::iterator iter = WaveInpNames.begin();' ...
  ,'  for(int i = 0; i < nInputPorts; i++)' ...
  ,'  {' ...
  ,'    InputRealPtrsType x = ssGetInputPortRealSignalPtrs(S,i);' ...
  ,'    int inputs = ssGetInputPortWidth(S,i);' ...
  ,'    if(iter != WaveInpNames.end())' ...
  ,'    {' ...
  ,'      for(int p = 0; p < inputs; p++)' ...
  ,'      {' ...
  ,'        if(x[p])' ...
  ,'        {' ...
  ,'          double value = *x[p];' ...
  ,'          SetInpValue(*iter, value, p);' ...
  ,'        }' ...
  ,'      }' ...
  ,'      iter++;' ...
  ,'    }' ...
  ,'  }' ...
  ,'' ...
  ,'  // call module loop' ...
  ,'  WavE_Loop();' ...
  ,'}' ...
  ,'#endif /* MDL_UPDATE */' ...
  ,'' ...
  ,'/* Function: mdlTerminate =====================================================' ...
  ,'* Abstract:' ...
  ,'*    In this function, you should perform any actions that are necessary' ...
  ,'*    at the termination of a simulation.  For example, if memory was' ...
  ,'*    allocated in mdlStart, this is the place to free it.' ...
  ,'*/' ...
  ,'static void mdlTerminate(SimStruct *S)' ...
  ,'{' ...
  ,'  // call module termination' ...
  ,'  WavE_Done();' ...
  ,'}' ...
  ,'#endif' ...
  ,'/*======================================================*' ...
  ,'* See sfuntmpl_doc.c for the optional S-function methods *' ...
  ,'*======================================================*/' ...
  ,'' ...
  ,'/*=============================*' ...
  ,'* Required S-function trailer *' ...
  ,'*=============================*/' ...
  ,'' ...
  ,'#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */' ...
  ,'//#include "simulink.c"      /* MEX-file interface mechanism */' ...
  ,'#else' ...
  ,'#include "cg_sfun.h"       /* Code generation registration function */' ...
  ,'#endif' ...
  ,'' ...
  ,'' ...
  ,'/* Function: mexCreateIOFiles =====================================================' ...
  ,'* Abstract:' ...
  ,'*    This function will generated the needed input / output variable' ...
  ,'*    interface files to create the model wrapper mdl file.' ...
  ,'*/' ...
  ,'extern "C" __declspec(dllexport) void __cdecl mexCreateIOFiles()' ...
  ,'{' ...
  ,'  FILE* fp = NULL;' ...
  ,'  fp = fopen("$$MOD_NAME$$.inp", "w");' ...
  ,'  if(fp)' ...
  ,'  {' ...
  ,'    char lbuf[32] = {0};' ...
  ,'    StrListT inputs;' ...
  ,'    GetInpNames(inputs, VART_NUMBER);' ...
  ,'    StrListT::iterator iter = inputs.begin();' ...
  ,'    while(iter != inputs.end())' ...
  ,'    {' ...
  ,'      std::string var_name = *iter;' ...
  ,'      _snprintf(lbuf, sizeof(lbuf), "%d", GetVarLength(var_name));' ...
  ,'      std::string line  = "";' ...
  ,'      line  = var_name;' ...
  ,'      line += ",";' ...
  ,'      line += lbuf;' ...
  ,'      line += "\\n";' ...
  ,'      fprintf(fp, line.c_str());' ...
  ,'      iter++;' ...
  ,'    }' ...
  ,'    fclose(fp);' ...
  ,'  }' ...
  ,'  fp = fopen("$$MOD_NAME$$.out", "w");' ...
  ,'  if(fp)' ...
  ,'  {' ...
  ,'    char lbuf[32] = {0};' ...
  ,'    StrListT outputs;' ...
  ,'    GetOutNames(outputs, VART_NUMBER);' ...
  ,'    StrListT::iterator iter = outputs.begin();' ...
  ,'    while(iter != outputs.end())' ...
  ,'    {' ...
  ,'      std::string var_name = *iter;' ...
  ,'      _snprintf(lbuf, sizeof(lbuf), "%d", GetVarLength(var_name));' ...
  ,'      std::string line  = "";' ...
  ,'      line  = var_name;' ...
  ,'      line += ",";' ...
  ,'      line += lbuf;' ...
  ,'      line += "\\n";' ...
  ,'      fprintf(fp, line.c_str());' ...
  ,'      iter++;' ...
  ,'    }' ...
  ,'    fclose(fp);' ...
  ,'  }' ...
  ,'}' ...
  };
end
function c = get_mex_py_file

  c = ...
  {'#-------------------------------------------------------------------------------' ...
  ,'# Name:        module1' ...
  ,'# Purpose:' ...
  ,'#' ...
  ,'# Author:      tftbe1' ...
  ,'#' ...
  ,'# Created:     25.10.2010' ...
  ,'# Copyright:   (c) tftbe1 2010' ...
  ,'# Licence:     <your licence>' ...
  ,'#-------------------------------------------------------------------------------' ...
  ,'#!/usr/bin/env python' ...
  ,'PY_FILE = \' ...
  ,'"""import os' ...
  ,'import sys' ...
  ,'import time' ...
  ,'import ctypes' ...
  ,'import shutil' ...
  ,'import _winreg' ...
  ,'from optparse import OptionParser' ...
  ,'' ...
  ,'MFILE = \\' ...
  ,'$$ABOSTR$$% $NAME$' ...
  ,'function d = $NAME$(state,d,info)' ...
  ,'%' ...
  ,'% function d = $NAME$(state,d,info)' ...
  ,'% state:      ''i'' init  - set outputstructure to d with info.n values (zero)' ...
  ,'%                       - set $SNAME$_input structure' ...
  ,'%                       - init with info.delta_t' ...
  ,'%             ''l'' loop  - set input-values from d with index info.index' ...
  ,'%                       - calculate function and set output to d-strucure' ...
  ,'%             ''d'' done  - reset function' ...
  ,'% d           vector structure with all inputs and outputs' ...
  ,'% info        structure with info.delta_t' ...
  ,'%                            info.index' ...
  ,'%                            info.n' ...
  ,'' ...
  ,'% Global variable' ...
  ,'global $SNAME$_input $SNAME$_output' ...
  ,'' ...
  ,'switch state' ...
  ,'% init' ...
  ,'%=====' ...
  ,'case ''i''' ...
  ,'  % check info-data' ...
  ,'  %----------------' ...
  ,'  if( ~isfield(info,''delta_t'') )' ...
  ,'    error(''$NAME$_error: delta_t (loop time [s]) is not in structure info'');' ...
  ,'  end' ...
  ,'  if( ~isfield(info,''n'') )' ...
  ,'    error(''$NAME$_error: n (n-loops (t1-t0)/delta_t+1) is not in structure info'');' ...
  ,'  end' ...
  ,'  if( ~isfield(info,''index'') )' ...
  ,'    error(''$NAME$_error: index (index at init == 1) is not in structure info'');' ...
  ,'  end' ...
  ,'' ...
  ,'  % check inputs and params' ...
  ,'  %------------------------' ...
  ,'$CHECK_INPUTS_AND_PARAMS$' ...
  ,'  % set inputs' ...
  ,'  %-----------' ...
  ,'  $SNAME$_input = [];' ...
  ,'$SET_INIT_INPUTS$' ...
  ,'  % call init function' ...
  ,'  %-------------------' ...
  ,'  $SNAME$_output = $MEX_NAME$(''i'',info,$SNAME$_input);' ...
  ,'' ...
  ,'  % set output structure names' ...
  ,'  %---------------------------' ...
  ,'$SET_OUTPUT_STRUCT_NAMES$' ...
  ,'  % set output' ...
  ,'  %-----------' ...
  ,'$SET_OUTPUTS$' ...
  ,'% loop' ...
  ,'%=====' ...
  ,'case ''l''' ...
  ,'  % set input' ...
  ,'  %----------' ...
  ,'$SET_INPUTS$' ...
  ,'  % call loop function' ...
  ,'  %-------------------' ...
  ,'  $SNAME$_output = $MEX_NAME$(''l'',$SNAME$_input);' ...
  ,'' ...
  ,'  % set output' ...
  ,'  %----------' ...
  ,'$SET_OUTPUTS$' ...
  ,'% done' ...
  ,'%=====' ...
  ,'case ''d''' ...
  ,'  $MEX_NAME$(''d'');' ...
  ,'end' ...
  ,'' ...
  ,'' ...
  ,'$CHECK_NAME_OF_STRUCT_FUNC$' ...
  ,'$$ABOSTR$$' ...
  ,'SET_OUTPUT_STRUCT_NAME = \' ...
  ,'$$ABOSTR$$  d.(''$VARNAME$'') = zeros(info.n,1);' ...
  ,'$$ABOSTR$$' ...
  ,'CHECK_INPUT = \' ...
  ,'$$ABOSTR$$  if( ~$NAME$_name_in_struct(d,''$VARNAME$'') )' ...
  ,'    error(''$NAME$_name_in_struct_error: %s is not in structure'',''$VARNAME$'');' ...
  ,'  end' ...
  ,'$$ABOSTR$$' ...
  ,'CHECK_PARAM = \' ...
  ,'$$ABOSTR$$  if( ~$NAME$_name_in_struct(d,''$PARNAME$'') )' ...
  ,'    d.$PARNAME$    = zeros(info.n,1);' ...
  ,'    d.$PARSETNAME$ = zeros(info.n,1);' ...
  ,'  end' ...
  ,'$$ABOSTR$$' ...
  ,'SET_INIT_INPUT = \' ...
  ,'$$ABOSTR$$  $SNAME$_input.(''$VARNAME_I$'') = d.(''$VARNAME_E$'')(info.index);' ...
  ,'$$ABOSTR$$' ...
  ,'SET_INPUT = \' ...
  ,'$$ABOSTR$$  $SNAME$_input.(''$VARNAME_I$'') = d.(''$VARNAME_E$'')(info.index);' ...
  ,'$$ABOSTR$$' ...
  ,'SET_OUTPUT = \' ...
  ,'$$ABOSTR$$  d.(''$VARNAME$'')(info.index) = $SNAME$_output.(''$VARNAME$'');' ...
  ,'$$ABOSTR$$' ...
  ,'CHECK_NAME_OF_STRUCT_FUNC = \' ...
  ,'$$ABOSTR$$function flag = $NAME$_name_in_struct(d,name)' ...
  ,'%' ...
  ,'% flag = $NAME$_name_in_struct(d,name)' ...
  ,'% search for struct-name' ...
  ,'% flag = 1 if found' ...
  ,'%' ...
  ,'flag = 0;' ...
  ,'if( isstruct(d) )' ...
  ,'    c_names = fieldnames(d);' ...
  ,'    for i=1:length(c_names)' ...
  ,'' ...
  ,'        if( strcmp(c_names{i},name) )' ...
  ,'          if( ~empty(d.(name)) )' ...
  ,'            flag = 1;' ...
  ,'          end' ...
  ,'          return' ...
  ,'        end' ...
  ,'    end' ...
  ,'end' ...
  ,'$$ABOSTR$$' ...
  ,'EXAMPLE_MFILE = \\' ...
  ,'$$ABOSTR$$' ...
  ,'info         = [];' ...
  ,'info.n       = 100;' ...
  ,'info.delta_t = 0.01;' ...
  ,'' ...
  ,'% set input (but normaly comes from measurement or function' ...
  ,'%----------' ...
  ,'d = [];' ...
  ,'$SET_INPUT_STRUCT_NAMES$' ...
  ,'' ...
  ,'% init' ...
  ,'%-----' ...
  ,'info.index = 1;' ...
  ,'d = $NAME$(''i'',d,info);' ...
  ,'' ...
  ,'for i=2:info.n' ...
  ,'  % loop' ...
  ,'  %-----' ...
  ,'  info.index = i;' ...
  ,'  d = $NAME$(''l'',d,info);' ...
  ,'end' ...
  ,'' ...
  ,'% done' ...
  ,'%-----' ...
  ,'$NAME$(''d'',d,info);' ...
  ,'' ...
  ,'$$ABOSTR$$' ...
  ,'SET_INPUT_STRUCT_NAME = \' ...
  ,'$$ABOSTR$$d.(''$VARNAME$'') = zeros(info.n,1);' ...
  ,'$$ABOSTR$$' ...
  ,'def ReadIOFiles(mod_s):' ...
  ,'  $$ABOSTR$$ inp_l   Listen aus Inputfile Liste der Spalten' ...
  ,'      out_l   Listen aus Outputfile Liste der Spalten' ...
  ,'  $$ABOSTR$$' ...
  ,'' ...
  ,'  file_names = [mod_s+".inp",mod_s+".out"]' ...
  ,'' ...
  ,'  for i in [0,1]:' ...
  ,'    file_name = file_names[i]' ...
  ,'    liste1 = []' ...
  ,'    if(os.path.exists(file_name)):' ...
  ,'      f = file(file_name,"r")' ...
  ,'      lines = f.readlines()' ...
  ,'      f.close()' ...
  ,'      for line in lines:' ...
  ,'        line = line.rstrip("\\n")' ...
  ,'        if( (line[0] != " ") and (line[0] != "%") and (line[0] != "!") and (line[0] != ";")  ):' ...
  ,'          if( line.find(",") > -1 ):  # Komma getrennt' ...
  ,'            liste = line.split(",")' ...
  ,'          else:' ...
  ,'            liste = line.split(" ")' ...
  ,'          liste1.append(liste)' ...
  ,'##          n = len(liste)' ...
  ,'##          if( n > 0 ):' ...
  ,'##            liste1.append(liste[0].lstrip().rstrip())' ...
  ,'##          if( (n > 1) and  not liste[1].lstrip().rstrip().isdigit() ):' ...
  ,'##            liste2.append(liste[1].lstrip().rstrip())' ...
  ,'##          else:' ...
  ,'##            liste2.append("")' ...
  ,'      if( i == 0 ):' ...
  ,'        inp_l = liste1' ...
  ,'      else:' ...
  ,'        out_l = liste1' ...
  ,'' ...
  ,'  return (inp_l,out_l)' ...
  ,'def MergeAndWriteInp(mod_s,inp_l_n,inpl_o):' ...
  ,'  inp_l = []' ...
  ,'  for inp in inp_l_n:' ...
  ,'    found = False' ...
  ,'    for inp2 in inp_l_o:' ...
  ,'      if( inp[0] == inp2[0] ):' ...
  ,'        found = True' ...
  ,'        break' ...
  ,'    liste = []' ...
  ,'    liste.append(inp[0])' ...
  ,'    if( found and len(inp2) > 2 ):' ...
  ,'      liste.append(inp2[1])' ...
  ,'    if( len(inp) > 1 ):' ...
  ,'      liste.append(inp[1])' ...
  ,'    inp_l.append(liste)' ...
  ,'' ...
  ,'  f = file(mod_s+".inp","w")' ...
  ,'  for inp in inp_l:' ...
  ,'    tt = ""' ...
  ,'    for item in inp:' ...
  ,'      tt = tt+item+","' ...
  ,'    tt = tt.rstrip(",")' ...
  ,'    f.write("%s\\n" % tt)' ...
  ,'' ...
  ,'  f.close()' ...
  ,'' ...
  ,'  return inp_l' ...
  ,'def CreateIOFiles(mdl_name):' ...
  ,'  hKey = 0' ...
  ,'  mdir = ""' ...
  ,'  try:' ...
  ,'    hKey  = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\MathWorks\MATLAB")' ...
  ,'  except:' ...
  ,'    pass' ...
  ,'  if hKey:' ...
  ,'    vlist = []' ...
  ,'    knum = 0' ...
  ,'    while 1:' ...
  ,'      try:' ...
  ,'        value = _winreg.EnumKey(hKey, knum)' ...
  ,'        vlist.append((value,float(value)))' ...
  ,'        knum += 1' ...
  ,'      except:' ...
  ,'        break' ...
  ,'    mversion = 0.0' ...
  ,'    sversion = ""' ...
  ,'    for ver in vlist:' ...
  ,'      if ver[1] > mversion:' ...
  ,'          mversion = ver[1]' ...
  ,'          sversion = ver[0]' ...
  ,'    try:' ...
  ,'      hKey  = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\MathWorks\MATLAB" + "\\\\" + sversion)' ...
  ,'      if hKey:' ...
  ,'        value, type = _winreg.QueryValueEx(hKey, "MATLABROOT")' ...
  ,'        mdir = value' ...
  ,'    except:' ...
  ,'      print "matlab dir in regestry not found"' ...
  ,'' ...
  ,'  if len(mdir) > 0:' ...
  ,'    mdir = os.path.join(mdir, "bin", "win32")' ...
  ,'  if not os.path.isdir(mdir): mdir = ""' ...
  ,'' ...
  ,'  if len(mdir):' ...
  ,'    wdir  = os.getcwd()' ...
  ,'    sfile = os.path.join(wdir, "mex_" + mdl_name)' ...
  ,'' ...
  ,'    # change to MATLAB dll directory' ...
  ,'    os.chdir(mdir)' ...
  ,'' ...
  ,'    # import sfunction module' ...
  ,'    cdll = ctypes.CDLL(sfile)' ...
  ,'' ...
  ,'    # change to working directory' ...
  ,'    os.chdir(wdir)' ...
  ,'' ...
  ,'    # create file' ...
  ,'    cdll.mexCreateIOFiles()' ...
  ,'' ...
  ,'def CreateMFile(inp_l, out_l, m_name, backup):' ...
  ,'  # kill extension' ...
  ,'  m_name = os.path.splitext(m_name)[0]' ...
  ,'' ...
  ,'  # create full name' ...
  ,'  m_name_f = os.path.join(os.getcwd(), m_name) + ".m"' ...
  ,'' ...
  ,'  # backup existing model' ...
  ,'  if backup:' ...
  ,'    if os.path.isfile(m_name_f):' ...
  ,'      time_s = time.strftime("_%Y_%m_%d_%H_%M_%S", time.localtime(os.path.getmtime(m_name_f)))' ...
  ,'      bak_m_name_f = os.path.join(os.getcwd(), m_name) + time_s + ".m"' ...
  ,'      os.system("copy \\"" + m_name_f + "\\" \\"" + bak_m_name_f + "\\"")' ...
  ,'' ...
  ,'  maxio = max(len(inp_l), len(out_l), 2)' ...
  ,'' ...
  ,'  s = MFILE' ...
  ,'' ...
  ,'  # Erstellen des Outputvektors' ...
  ,'  s1 = ""' ...
  ,'  for o in out_l:' ...
  ,'      s2 = SET_OUTPUT_STRUCT_NAME' ...
  ,'      s2 = s2.replace("$VARNAME$",o[0])' ...
  ,'      s1 += s2' ...
  ,'  s = s.replace("$SET_OUTPUT_STRUCT_NAMES$",s1)' ...
  ,'' ...
  ,'  # Check Input' ...
  ,'  s1 = ""' ...
  ,'  for i in inp_l:' ...
  ,'      name_intern = i[0]' ...
  ,'      if( len(i) > 1 and not i[1].isdigit() ):' ...
  ,'        name_extern = i[1]' ...
  ,'      else:' ...
  ,'        name_extern = i[0]' ...
  ,'      # Parameter suchen' ...
  ,'      if( name_extern.find("P_") == 0 ):' ...
  ,'          s2 = CHECK_PARAM' ...
  ,'          s2 = s2.replace("$NAME$",m_name)' ...
  ,'          s2 = s2.replace("$PARNAME$",name_extern)' ...
  ,'          name = "Pset_"+name_extern[2:len(name_extern)]' ...
  ,'          s2 = s2.replace("$PARSETNAME$",name)' ...
  ,'          s1 += s2' ...
  ,'      elif(name_extern.find("Pset_") == 0 ):' ...
  ,'          pass' ...
  ,'      else:' ...
  ,'          s2 = CHECK_INPUT' ...
  ,'          s2 = s2.replace("$NAME$",m_name)' ...
  ,'          s2 = s2.replace("$VARNAME$",name_extern)' ...
  ,'          s1 += s2' ...
  ,'  s = s.replace("$CHECK_INPUTS_AND_PARAMS$",s1)' ...
  ,'' ...
  ,'# set init input' ...
  ,'  s1 = ""' ...
  ,'  for i in inp_l:' ...
  ,'      name_intern = i[0]' ...
  ,'      if( len(i) > 1 and  not i[1].isdigit() ):' ...
  ,'        name_extern = i[1]' ...
  ,'      else:' ...
  ,'        name_extern = i[0]' ...
  ,'      s3 = SET_INIT_INPUT' ...
  ,'      s3 = s3.replace("$VARNAME_I$",name_intern)' ...
  ,'      s3 = s3.replace("$VARNAME_E$",name_extern)' ...
  ,'      s1 += s3' ...
  ,'  s = s.replace("$SET_INIT_INPUTS$",s1)' ...
  ,'' ...
  ,'  # Loop Function' ...
  ,'  s1 = ""' ...
  ,'  for i in inp_l:' ...
  ,'      name_intern = i[0]' ...
  ,'      if( len(i) > 1 and  not i[1].isdigit() ):' ...
  ,'        name_extern = i[1]' ...
  ,'      else:' ...
  ,'        name_extern = i[0]' ...
  ,'      s2 = SET_INPUT' ...
  ,'      s2 = s2.replace("$VARNAME_I$",name_intern)' ...
  ,'      s2 = s2.replace("$VARNAME_E$",name_extern)' ...
  ,'      s1 += s2' ...
  ,'  s = s.replace("$SET_INPUTS$",s1)' ...
  ,'' ...
  ,'  s1 = ""' ...
  ,'  for o in out_l:' ...
  ,'      s2 = SET_OUTPUT' ...
  ,'      s2 = s2.replace("$VARNAME$",o[0])' ...
  ,'      s1 += s2' ...
  ,'  s = s.replace("$SET_OUTPUTS$",s1)' ...
  ,'' ...
  ,'  # Zusatzfunktionen' ...
  ,'  s = s.replace("$CHECK_NAME_OF_STRUCT_FUNC$",CHECK_NAME_OF_STRUCT_FUNC)' ...
  ,'' ...
  ,'  # allgemeines Ersetzen' ...
  ,'  s = s.replace("$NAME$", m_name)' ...
  ,'  s = s.replace("$SNAME$", m_name.lower())' ...
  ,'  s = s.replace("$MEX_NAME$","mex_"+m_name)' ...
  ,'' ...
  ,'  f = open(m_name_f, "w")' ...
  ,'  f.write(s)' ...
  ,'  f.close()' ...
  ,'' ...
  ,'  # Beispiel m-File' ...
  ,'  #----------------' ...
  ,'  s = EXAMPLE_MFILE' ...
  ,'' ...
  ,'  # Erstellen des Outputvektors' ...
  ,'  s1 = ""' ...
  ,'  for i in inp_l:' ...
  ,'      name_intern = i[0]' ...
  ,'      if( len(i) > 1 and not i[1].isdigit() ):' ...
  ,'        name_extern = i[1]' ...
  ,'      else:' ...
  ,'        name_extern = i[0]' ...
  ,'      s2 = SET_INPUT_STRUCT_NAME' ...
  ,'      s2 = s2.replace("$VARNAME$",name_extern)' ...
  ,'      s1 += s2' ...
  ,'  s = s.replace("$SET_INPUT_STRUCT_NAMES$",s1)' ...
  ,'  s = s.replace("$NAME$", m_name)' ...
  ,'  s = s.replace("$SNAME$", m_name.lower())' ...
  ,'' ...
  ,'  # Beispielaufrufe' ...
  ,'  f = open(m_name+"_example_run.m", "w")' ...
  ,'  f.write(s)' ...
  ,'  f.close()' ...
  ,'' ...
  ,'  return m_name_f' ...
  ,'if __name__ == "__main__":' ...
  ,'  # check command line options' ...
  ,'  parser = OptionParser()' ...
  ,'  parser.add_option("-f", "--file", dest="filename",' ...
  ,'                    help="specify target model file name (without extension)")' ...
  ,'  parser.add_option("-b", "--nobackup", dest="backup", default=True,' ...
  ,'                    action="store_false", help="do not backup existing model file")' ...
  ,'  parser.add_option("-m", "--startmatlab", dest="startmatlab", default=False,' ...
  ,'                    action="store_true", help="start matlab after generating model file")' ...
  ,'' ...
  ,'  (options, args) = parser.parse_args()' ...
  ,'' ...
  ,'  # create io files' ...
  ,'  mod_s = "$$MOD_NAME$$"' ...
  ,'  (inp_l_o,out_l_o)= ReadIOFiles(mod_s)' ...
  ,'  CreateIOFiles(mod_s)' ...
  ,'  inp_l = [s.split('','') for s in open(mod_s + ".inp").read().split("\\n") if len(s) > 0]' ...
  ,'  out_l = [s.split('','') for s in open(mod_s + ".out").read().split("\\n") if len(s) > 0]' ...
  ,'  inp_l=MergeAndWriteInp(mod_s,inp_l,inp_l_o)' ...
  ,'' ...
  ,'  # create model file' ...
  ,'  file = mod_s' ...
  ,'  if options.filename:' ...
  ,'    file = options.filename' ...
  ,'  m_name_f = CreateMFile(inp_l, out_l, mod_s, options.backup)' ...
  ,'' ...
  ,'' ...
  ,'  # Copy into destination' ...
  ,'  if( len(args) > 0 and os.path.isdir(args[0])):' ...
  ,'      tpath = args[0]' ...
  ,'      spath = os.getcwd()' ...
  ,'      sfile = os.path.join(spath, "mex_" + mod_s + ".dll")' ...
  ,'      tfile = os.path.join(tpath, "mex_" + mod_s + ".dll")' ...
  ,'      try:' ...
  ,'        shutil.copy(sfile,tfile)' ...
  ,'        print "copy %s %s" % (sfile,tfile)' ...
  ,'      except:' ...
  ,'        print "error: copy %s %s" % (sfile,tfile)' ...
  ,'' ...
  ,'      if( len(m_name_f) > 0 ):' ...
  ,'          sfile = os.path.join(spath, mod_s + ".m")' ...
  ,'          tfile = os.path.join(tpath, mod_s + ".m")' ...
  ,'          try:' ...
  ,'            shutil.copy(sfile,tfile)' ...
  ,'            print "copy %s %s" % (sfile,tfile)' ...
  ,'          except:' ...
  ,'            print "error: copy %s %s" % (sfile,tfile)' ...
  ,'' ...
  ,'          sfile = os.path.join(spath, mod_s + ".inp")' ...
  ,'          tfile = os.path.join(tpath, mod_s + ".inp")' ...
  ,'          try:' ...
  ,'            shutil.copy(sfile,tfile)' ...
  ,'            print "copy %s %s" % (sfile,tfile)' ...
  ,'          except:' ...
  ,'            print "error: copy %s %s" % (sfile,tfile)' ...
  ,'' ...
  ,'          sfile = os.path.join(spath, mod_s + ".out")' ...
  ,'          tfile = os.path.join(tpath, mod_s + ".out")' ...
  ,'          try:' ...
  ,'            shutil.copy(sfile,tfile)' ...
  ,'            print "copy %s %s" % (sfile,tfile)' ...
  ,'          except:' ...
  ,'            print "error: copy %s %s" % (sfile,tfile)' ...
  ,'' ...
  };
end